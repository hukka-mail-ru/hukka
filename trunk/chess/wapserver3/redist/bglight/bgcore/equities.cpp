#if defined( __GNUG__ )
#pragma implementation
#endif

/*
 * equities.cc
 *
 * by Joseph Heled, 2002
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "bgdefs.h"

#include "equities.h"

namespace Equities {

//  Table generated by mec.c,
//  (Copyright (C) 1996  Claes Thornberg (claest@it.kth.se)), using 
//    Gammon rate 0.2600
//    Winning %   0.5000
//
float const 
equitiesTable[25][25] =
{

  { 0.500f, 0.685f, 0.750f, 0.818f, 0.842f, 0.892f, 0.909f, 0.936f, 0.946f,
    0.962f, 0.968f, 0.978f, 0.981f, 0.987f, 0.989f, 0.992f, 0.993f, 0.995f,
    0.996f, 0.997f, 0.998f, 0.998f, 0.999f, 0.999f, 0.999f,
  } ,
  { 0.315f, 0.500f, 0.595f, 0.664f, 0.737f, 0.795f, 0.835f, 0.869f, 0.896f,
    0.919f, 0.935f, 0.949f, 0.959f, 0.969f, 0.975f, 0.981f, 0.984f, 0.988f,
    0.990f, 0.993f, 0.994f, 0.995f, 0.996f, 0.997f, 0.998f,
  } ,
  { 0.250f, 0.405f, 0.500f, 0.571f, 0.646f, 0.710f, 0.758f, 0.800f, 0.835f,
    0.867f, 0.890f, 0.911f, 0.927f, 0.942f, 0.952f, 0.962f, 0.969f, 0.975f,
    0.980f, 0.984f, 0.987f, 0.990f, 0.992f, 0.993f, 0.995f,
  } ,
  { 0.182f, 0.336f, 0.429f, 0.500f, 0.575f, 0.640f, 0.694f, 0.739f, 0.781f,
    0.817f, 0.847f, 0.872f, 0.894f, 0.912f, 0.927f, 0.940f, 0.950f, 0.960f,
    0.967f, 0.973f, 0.978f, 0.982f, 0.985f, 0.988f, 0.990f,
  } ,
  { 0.158f, 0.263f, 0.354f, 0.425f, 0.500f, 0.567f, 0.623f, 0.673f, 0.720f,
    0.761f, 0.796f, 0.827f, 0.853f, 0.876f, 0.895f, 0.912f, 0.926f, 0.939f,
    0.949f, 0.958f, 0.965f, 0.971f, 0.976f, 0.980f, 0.984f,
  } ,
  { 0.108f, 0.205f, 0.290f, 0.360f, 0.433f, 0.500f, 0.559f, 0.612f, 0.662f,
    0.706f, 0.746f, 0.780f, 0.811f, 0.838f, 0.861f, 0.882f, 0.900f, 0.915f,
    0.928f, 0.939f, 0.949f, 0.957f, 0.964f, 0.970f, 0.975f,
  } ,
  { 0.091f, 0.165f, 0.242f, 0.306f, 0.377f, 0.441f, 0.500f, 0.553f, 0.605f,
    0.652f, 0.694f, 0.732f, 0.766f, 0.797f, 0.824f, 0.848f, 0.869f, 0.888f,
    0.904f, 0.918f, 0.930f, 0.940f, 0.949f, 0.957f, 0.964f,
  } ,
  { 0.064f, 0.131f, 0.200f, 0.261f, 0.327f, 0.388f, 0.447f, 0.500f, 0.552f,
    0.600f, 0.645f, 0.685f, 0.722f, 0.755f, 0.785f, 0.812f, 0.836f, 0.858f,
    0.877f, 0.894f, 0.908f, 0.921f, 0.932f, 0.942f, 0.951f,
  } ,
  { 0.054f, 0.104f, 0.165f, 0.219f, 0.280f, 0.338f, 0.395f, 0.448f, 0.500f,
    0.549f, 0.595f, 0.637f, 0.676f, 0.712f, 0.745f, 0.774f, 0.801f, 0.825f,
    0.847f, 0.867f, 0.884f, 0.899f, 0.913f, 0.924f, 0.935f,
  } ,
  { 0.038f, 0.081f, 0.133f, 0.183f, 0.239f, 0.294f, 0.348f, 0.400f, 0.451f,
    0.500f, 0.547f, 0.590f, 0.631f, 0.669f, 0.703f, 0.735f, 0.765f, 0.791f,
    0.816f, 0.838f, 0.857f, 0.875f, 0.891f, 0.905f, 0.917f,
  } ,
  { 0.032f, 0.065f, 0.110f, 0.153f, 0.204f, 0.254f, 0.306f, 0.355f, 0.405f,
    0.453f, 0.500f, 0.544f, 0.586f, 0.625f, 0.662f, 0.695f, 0.727f, 0.756f,
    0.782f, 0.807f, 0.829f, 0.848f, 0.866f, 0.883f, 0.897f,
  } ,
  { 0.022f, 0.051f, 0.089f, 0.128f, 0.173f, 0.220f, 0.268f, 0.315f, 0.363f,
    0.410f, 0.456f, 0.500f, 0.542f, 0.582f, 0.620f, 0.656f, 0.689f, 0.720f,
    0.748f, 0.774f, 0.798f, 0.820f, 0.840f, 0.859f, 0.875f,
  } ,
  { 0.019f, 0.041f, 0.073f, 0.106f, 0.147f, 0.189f, 0.234f, 0.278f, 0.324f,
    0.369f, 0.414f, 0.458f, 0.500f, 0.540f, 0.579f, 0.616f, 0.650f, 0.682f,
    0.713f, 0.741f, 0.767f, 0.791f, 0.813f, 0.833f, 0.851f,
  } ,
  { 0.013f, 0.031f, 0.058f, 0.088f, 0.124f, 0.162f, 0.203f, 0.245f, 0.288f,
    0.331f, 0.375f, 0.418f, 0.460f, 0.500f, 0.539f, 0.576f, 0.612f, 0.645f,
    0.677f, 0.706f, 0.734f, 0.760f, 0.784f, 0.805f, 0.826f,
  } ,
  { 0.011f, 0.025f, 0.048f, 0.073f, 0.105f, 0.139f, 0.176f, 0.215f, 0.255f,
    0.297f, 0.338f, 0.380f, 0.421f, 0.461f, 0.500f, 0.538f, 0.574f, 0.608f,
    0.641f, 0.672f, 0.701f, 0.728f, 0.753f, 0.777f, 0.799f,
  } ,
  { 0.008f, 0.019f, 0.038f, 0.060f, 0.088f, 0.118f, 0.152f, 0.188f, 0.226f,
    0.265f, 0.305f, 0.344f, 0.384f, 0.424f, 0.462f, 0.500f, 0.536f, 0.571f,
    0.605f, 0.637f, 0.667f, 0.695f, 0.722f, 0.747f, 0.771f,
  } ,
  { 0.007f, 0.016f, 0.031f, 0.050f, 0.074f, 0.100f, 0.131f, 0.164f, 0.199f,
    0.235f, 0.273f, 0.311f, 0.350f, 0.388f, 0.426f, 0.464f, 0.500f, 0.535f,
    0.569f, 0.602f, 0.633f, 0.663f, 0.691f, 0.717f, 0.742f,
  } ,
  { 0.005f, 0.012f, 0.025f, 0.040f, 0.061f, 0.085f, 0.112f, 0.142f, 0.175f,
    0.209f, 0.244f, 0.280f, 0.318f, 0.355f, 0.392f, 0.429f, 0.465f, 0.500f,
    0.534f, 0.567f, 0.599f, 0.630f, 0.659f, 0.686f, 0.712f,
  } ,
  { 0.004f, 0.010f, 0.020f, 0.033f, 0.051f, 0.072f, 0.096f, 0.123f, 0.153f,
    0.184f, 0.218f, 0.252f, 0.287f, 0.323f, 0.359f, 0.395f, 0.431f, 0.466f,
    0.500f, 0.533f, 0.566f, 0.597f, 0.626f, 0.655f, 0.682f,
  } ,
  { 0.003f, 0.007f, 0.016f, 0.027f, 0.042f, 0.061f, 0.082f, 0.106f, 0.133f,
    0.162f, 0.193f, 0.226f, 0.259f, 0.294f, 0.328f, 0.363f, 0.398f, 0.433f,
    0.467f, 0.500f, 0.532f, 0.564f, 0.594f, 0.623f, 0.651f,
  } ,
  { 0.002f, 0.006f, 0.013f, 0.022f, 0.035f, 0.051f, 0.070f, 0.092f, 0.116f,
    0.143f, 0.171f, 0.202f, 0.233f, 0.266f, 0.299f, 0.333f, 0.367f, 0.401f,
    0.434f, 0.468f, 0.500f, 0.532f, 0.562f, 0.592f, 0.621f,
  } ,
  { 0.002f, 0.005f, 0.010f, 0.018f, 0.029f, 0.043f, 0.060f, 0.079f, 0.101f,
    0.125f, 0.152f, 0.180f, 0.209f, 0.240f, 0.272f, 0.305f, 0.337f, 0.370f,
    0.403f, 0.436f, 0.468f, 0.500f, 0.531f, 0.561f, 0.590f,
  } ,
  { 0.001f, 0.004f, 0.008f, 0.015f, 0.024f, 0.036f, 0.051f, 0.068f, 0.087f,
    0.109f, 0.134f, 0.160f, 0.187f, 0.216f, 0.247f, 0.278f, 0.309f, 0.341f,
    0.374f, 0.406f, 0.438f, 0.469f, 0.500f, 0.530f, 0.560f,
  } ,
  { 0.001f, 0.003f, 0.007f, 0.012f, 0.020f, 0.030f, 0.043f, 0.058f, 0.076f,
    0.095f, 0.117f, 0.141f, 0.167f, 0.195f, 0.223f, 0.253f, 0.283f, 0.314f,
    0.345f, 0.377f, 0.408f, 0.439f, 0.470f, 0.500f, 0.530f,
  } ,
  { 0.001f, 0.002f, 0.005f, 0.010f, 0.016f, 0.025f, 0.036f, 0.049f, 0.065f,
    0.083f, 0.103f, 0.125f, 0.149f, 0.174f, 0.201f, 0.229f, 0.258f, 0.288f,
    0.318f, 0.349f, 0.379f, 0.410f, 0.440f, 0.470f, 0.500f,
  } ,
};

// Obtained from self play.

static float
postProbs[] =
{ 0.50000f,
  0.484988779204f,
  0.3195f,
  0.302313595788f,
  0.18935485f,
  0.175375581897f,
  0.11368904122f,
  0.104665411717f,
  0.067397551901f,
  0.0615931228385f,
  0.039882714542f,
  0.0368401457886f,
  0.023532346981f,
  0.0220564138613f,
  0.0143039149194f,
  0.0128627481489f,
  0.00849200040717f,
  0.00770736867884f,
  0.00509230940013f,
  0.0046016493719f,
  0.00305933550471f,
  0.00272992874382f,
  0.0018220307613f,
  0.00164332944811f,
};


float
probPost(int const xAway)
{
  if( xAway <= 0 ) {
    return 1.0f;
  }

  {         assert( uint(xAway) <= sizeof(postProbs)/sizeof(postProbs[0]) ); }
  
  return postProbs[xAway - 1];
}

float
prob(int const xAway, int const oAway, bool const crawford)
{
  if( (xAway == 1 || oAway == 1) && ! crawford ) {
    if( xAway == 1 ) {
      return 1.0 - probPost(oAway);
    } else {
      return probPost(xAway);
    }
  }

  return prob(xAway, oAway);
}


}

using namespace Equities;

namespace BG {

MatchState::MatchState(void) :
  xAway(0),
  oAway(0),
  cube(1),
  xOwns(false),
  crawfordGame(false),
  xCube2(1.0),
  xCube3(1.0),
  oCube2(-1.0),
  oCube3(-1)
{}

float
MatchState::matchEquity(CubelessProbs const p, bool const xOnPlay) const
{
  float e = 2 * p[WIN] - 1;
  
  if( xOnPlay ) {
    e += (xCube2 * p[WINGAMMON]  + xCube3 * p[WINBACKGAMMON] +
	  oCube2 * p[LOSEGAMMON] + oCube3 * p[LOSEBACKGAMMON]);
  } else {
    e -= (oCube2 * p[WINGAMMON]  + oCube3 * p[WINBACKGAMMON] +
	  xCube2 * p[LOSEGAMMON] + xCube3 * p[LOSEBACKGAMMON]);
  }

  return e;
}


void
MatchState::recompute(void)
{
  if( xAway == 0 && oAway == 0 ) {
    xCube2 = 1.0;
    xCube3 = 1.0;
    oCube2 = -1.0;
    oCube3 = -1.0;
    return;
  }
  
  if( xAway == 1 && oAway == 1 ) {
    xCube2 = xCube3 = 0.0;
    oCube2 = oCube3 = 0.0;
    return;
  }

  if( xAway == 1 ) {
    float const p01 = 1 - probPost(oAway - cube);
    float const p02 = 1 - probPost(oAway - 2*cube);
    float const p03 = 1 - probPost(oAway - 3*cube);

    float const p10 = 1.0;
    
    float const center = (p10 + p01) / 2.0;
    float const one = p10 - center;
    
    float const cube2 = (p02 - center) / one;
    float const cube3 = (p03 - center) / one;

    oCube2 = cube2 + 1.0;
    oCube3 = cube3 - cube2;
    
    xCube2 = xCube3 = 0.0;

    return;
  }

  if( oAway == 1 ) {
    float const p10 = probPost(xAway - cube);
    float const p20 = probPost(xAway - 2*cube);
    float const p30 = probPost(xAway - 3*cube);

    float const p01 = 0.0;
    
    float const center = (p10 + p01) / 2.0;
    float const one = p10 - center;
    
    float const cube2 = (p20 - center) / one;
    float const cube3 = (p30 - center) / one;

    oCube2 = oCube3 = 0.0;

    xCube2 = cube2 - 1.0;
    xCube3 = cube3 - cube2;
    
    return;
  }

  
  float const p10 =  prob(xAway - cube, oAway);
  float const p01 =  prob(xAway, oAway - cube);
  float const p20 =  prob(xAway - 2*cube, oAway);
  float const p02 =  prob(xAway, oAway - 2*cube);
  float const p30 =  prob(xAway - 3*cube, oAway);
  float const p03 =  prob(xAway, oAway - 3*cube);
  
  float const center = (p10 + p01) / 2.0;
  float const one = p10 - center;
  
  float const x2 = (p20 - center) / one;
  float const o2 = (p02 - center) / one;

  float const x3 = (p30 - center) / one;
  float const o3 = (p03 - center) / one;

  xCube3 = x3 - x2;
  xCube2 = x2 - 1.0;

  oCube3 = o3 - o2;
  oCube2 = o2 + 1.0;
}


bool
MatchState::set(uint        xAway_,
		uint        oAway_,
		uint        cube_,
		bool const  xOwns_,
		int         crawford)
{
  if( xAway_ == 0 ) {
    xAway_ = xAway;
  }

  if( oAway_ == 0 ) {
    oAway_ = oAway;
  }

  if( xAway != xAway_ || oAway_ != oAway ) {
    xAway = xAway_;
    oAway = oAway_;

    if( ! (xAway <= 25 && oAway <= 25 ) ) {
      return false;
    }

    recompute();
  }

  if( cube_ != 0 && cube_ != cube ) {
    cube = cube_;
    xOwns = xOwns_;

    if( cube == 0 || (cube & (cube-1)) != 0 ) {
      return false;
    }
    
    recompute();
  }
  
  if( crawford >= 0 ) {
    crawfordGame = crawford;
  }

  return true;
}



float
MatchState::mwcMatch(CubelessProbs const ar, bool const xOnPlay) const
{
  float const xWins = xOnPlay ? ar[WIN] : 1 - ar[WIN];
  float const xGammons = xOnPlay ? ar[WINGAMMON] : ar[LOSEGAMMON];
  float const oWins = 1 - xWins;
  float const oGammons = xOnPlay? ar[LOSEGAMMON] : ar[WINGAMMON];

  float const xGammonRatio = (xWins > 0) ? xGammons / xWins : 0.0;
  float const oGammonRatio = (oWins > 0) ? oGammons / oWins : 0.0;

  // perfect live cube window
  Es el;

  if( cube == 1 || xOwns || crawfordGame ) {
    get(el, 0, xAway, oAway, cube, xGammonRatio, oGammonRatio,
		  crawfordGame
#if defined( DEBUG )
		  /* ,Analyze::adebug >= 1 */ ,false
#endif
      );
      
  } else {
    // O owns a > 1 cube, non crawford
    
    get(el, 0, oAway, xAway, cube, oGammonRatio, xGammonRatio,
		  false
#if defined( DEBUG )
		  /* ,Analyze::adebug >= 1 */ ,false
#endif
      );
      el.reverse();
  }

  uint const eCube =
    (cube == 1 && (xAway == 1 || oAway == 1) && ! crawfordGame) ? 2 : cube;
  
  float const xBGammons = xOnPlay ? ar[WINBACKGAMMON] : ar[LOSEBACKGAMMON];
  float const xbgr = xGammons > 0 ? (xBGammons / xGammons) : 0.0;

  float const oBGammons = xOnPlay ? ar[LOSEBACKGAMMON] : ar[WINBACKGAMMON];
  float const obgr = oGammons > 0 ? (oBGammons / oGammons) : 0.0;

  {
    float const hdif = oAway > 1 ?
      (value(xAway - 3*eCube, oAway) -
       value(xAway - 2*eCube, oAway)) :
      (ePost(xAway - 3*eCube) - (ePost(xAway - 2*eCube)));
    
    el.yHigh += xbgr * xGammonRatio * hdif;

    if( el.yHigh > 1.0 ) el.yHigh = 1;

    float const ldif = xAway > 1 ?
      (value(xAway, oAway - 3*eCube) -
       value(xAway, oAway - 2*eCube)) :
      
      -(ePost(oAway - 3*eCube) - (ePost(oAway - 2*eCube)));
      
    el.yLow += obgr * oGammonRatio * ldif;
    
    if( el.yLow < -1.0 ) el.yLow = -1.0;
  }

  Es dead = el;
  
  if( xWins > el.xHigh ) {
    el.xLow = el.xHigh;
    el.yLow = el.yHigh;

    el.xHigh = 1.0;
    el.yHigh = eWhenWin(xGammonRatio, xbgr, xAway, oAway, eCube);
  } else if( xWins < el.xLow ) {
    
    el.xHigh = el.xLow;
    el.yHigh = el.yLow;

    el.xLow = 0;
    el.yLow = eWhenLose(oGammonRatio, obgr, xAway, oAway, eCube);
  }


  float const elv = el.y(xWins);

  float ed;

  if( (xAway == 1 || oAway == 1) ) {
    ed = elv;
  } else {
    
    float const dyh =
      el.xHigh == 1.0 ? el.yHigh :
      eWhenWin(xGammonRatio, xbgr, xAway, oAway, cube);
    
    float const dyl =
      el.xLow == 0.0 ? el.yLow :
      eWhenLose(oGammonRatio, obgr, xAway, oAway, cube);
      
    if( cube == 1 ) {
      if( xWins > dead.xHigh ) {
	dead.xHigh = 1.0;  dead.yHigh = dyh;

	ed = (dead.y(xWins) + elv) / 2;

      } else if( xWins < dead.xLow ) {
	dead.xLow = 0.0;  dead.yLow = dyl;

	ed = (dead.y(xWins) + elv) / 2;

      } else {

	dead.xLow = 0; dead.yLow = dyl;
	ed = dead.y(xWins);

	dead = el;
	dead.xHigh = 1.0; dead.yHigh = dyh;
	ed += dead.y(xWins);

	ed /= 2.0;
      }
    } else {
      if( xOwns ) {
	el.xHigh = 1.0;
	el.yHigh = dyh;
      } else {
	el.xLow = 0;
	el.yLow = dyl;
      }
    
      ed = el.y(xWins);
    }
  }

  float const cubeLife = 0.78f;
  
  float const e1 = cubeLife * elv + (1-cubeLife) * ed;
  
  return xOnPlay ? e1 : -e1;
}



float
MatchState::mwc(CubelessProbs const p, bool const xOnPlay) const
{
  if( xAway == 0 && oAway == 0 ) {
    // money
    return matchEquity(p, xOnPlay);
  }
  
  return mwcMatch(p, xOnPlay);
}

}


namespace Equities {



static void
getPre(Es&          now,
       Es* const    doubled,
       uint const   xAway,
       uint const   oAway,
       uint const   cube,
       bool const   xOwns,
       float const  xGammonRatio,
       float const  oGammonRatio
#if defined( DEBUG )
       ,bool	const debug
#endif 
  )
{
#if defined( DEBUG )
  if( debug ) {
    cout << "get cube=" << cube << " -" << xAway << ",-" << oAway
	 << ((cube > 1) ? (xOwns ? " X owns " : " O owns ") : "")
	 << endl;
  }
#endif
  
  if( cube == 1 ) {
    // Equity at twice cube, after O doubles
    
    getPre(now, 0, xAway, oAway, 2*cube, true, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	,debug
#endif
      );

    float const xdrop = value(xAway, oAway - cube);
    
    float const xl = now.x(xdrop);
    
    // Equity at twice cube, after X doubles
    
    getPre(now, 0, xAway, oAway, 2*cube, false, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	,debug
#endif
	);
    
    float const odrop = value(xAway - cube, oAway);
    
    float const xh = now.x(odrop);

    if( doubled ) {
      *doubled = now;
    }
    
    now.xLow = xl;
    now.yLow = xdrop;
    
    now.xHigh = xh;
    now.yHigh = odrop;
    
  } else {
    if( xOwns ) {
      // X holds cube
      
      if( xAway <= cube ) {
	// cube dead, at 1 he wins

	now.xHigh = 1.0;
	now.yHigh = 1.0;

	if( doubled ) {
	  doubled->xHigh = 1.0;
	  doubled->yHigh = 1.0;
	  // if doubles (silly), opponent will re-double if needed
	  doubled->xLow = 0.0;
	  doubled->yLow = eqWhenLose(oGammonRatio, xAway, oAway, 4*cube);
	}
	
      } else {
	// Lets get X equity at twice cube with O holding.
      
	getPre(now, 0, xAway, oAway, 2*cube, !xOwns, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	       ,debug
#endif
	    );

	// O will drop at this point
	
	float const edrop = value(xAway - cube, oAway);

	// which is rdp%  for X
	
	float const rdp = now.x(edrop);

	if( doubled ) {
	  *doubled = now;
	}
      
	now.yHigh = edrop;
	now.xHigh = rdp;
      }

      // at 0 he lose, xAway, oAway-cube or oAway-2*cube
      
      now.yLow = eqWhenLose(oGammonRatio, xAway, oAway, cube);
      now.xLow = 0;
      
    } else {
      if( oAway <= cube ) {
	// o holds cube, cube dead
	// at 0 o wins

	now.xLow = 0;
	now.yLow = -1;

	if( doubled ) {
	  doubled->xLow = 0;
	  doubled->yLow = -1;

	  // if doubles (silly), opponent will re-double if needed
	  doubled->xHigh = 1.0;
	  doubled->yHigh = eqWhenWin(xGammonRatio, xAway, oAway, 4*cube);
	}

      } else {

	getPre(now, 0, xAway, oAway, 2*cube, !xOwns, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	       ,debug
#endif
	    );
	
	float const edrop = value(xAway, oAway - cube);

	float rdp = now.x(edrop);

	if( doubled ) {
	  *doubled = now;
	}
	
	now.xLow = rdp;
	now.yLow = edrop;
      }

      // to win X needs to climb to 100% (1)
      
      now.xHigh = 1.0;
      now.yHigh = eqWhenWin(xGammonRatio, xAway, oAway, cube);
    }
  }

#if defined( DEBUG )
  if( debug ) {
    cout << "get cube=" << cube << " -" << xAway << ",-" << oAway
	 << ((cube > 1) ? (xOwns ? " X owns " : " O owns ") : "")
	 << endl;
    
    cout << " return now = " << now;
    if( doubled ) {
      cout << " doubled " << *doubled;
    }
    cout << endl;
  }
#endif

}

void
get(Es&          now,
    Es* const    doubled,
    uint const   xAway,
    uint const   oAway,
    uint const   cube,
    float const  xGammonRatio,
    float const  oGammonRatio
#if defined( DEBUG )
    ,int	const debug
#endif 
  )
{
#if defined( DEBUG )
    if( debug == 1 ) {
      cout << "get cube=" << cube << " -" << xAway << ",-" << oAway
	   << ((cube > 1) ? " X owns " : "") << endl;
    }
#endif

  if( xAway > 1 && oAway > 1 ) {
    getPre(now, doubled, xAway, oAway, cube, true, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	   ,debug > 1
#endif
	 );
  } else {
    // post crawford
    
    if( xAway == 1 && oAway == 1 ) {
      now.xHigh = 1.0;
      now.yHigh = 1.0;
      now.xLow = 0.0;
      now.yLow = -1.0;

      if( doubled ) {
	*doubled = now;
      }
    
      return;
    }

    if( cube == 1 ) {
      int const away = xAway == 1 ? oAway : xAway;
    
      float const gr = xAway == 1 ? oGammonRatio : xGammonRatio;
    
      now.xLow = 0.0;
      now.yLow = -1.0;
      
      now.xHigh = 1.0;
      now.yHigh = eWhenWinPost(gr, away, 2*cube);

      float const odrop = ePost(away - cube);
      float const xh = now.x(odrop);

      if( doubled ) {
	*doubled = now;
      }

      now.xHigh = xh;
      now.yHigh = odrop;

      if( xAway == 1 ) {
	now.reverse();
	if( doubled ) {
	  doubled->reverse();
	}
      }
    } else {
      // post crawford, cube turned
      
      if( oAway == 1 ) {
	// 1-away doubled. is it you kaufmann?
	
	now.xLow = 0.0;
	now.yLow = -1.0;
	
	now.xHigh = 1.0;
	now.yHigh = eWhenWinPost(xGammonRatio, xAway, 2*cube);
	
	if( doubled ) {
	  *doubled = now;
	}
      } else {
	now.xHigh = 1.0;
	now.yHigh = 1.0;
      
	now.xLow = 0.0;
	now.yLow = -eWhenWinPost(oGammonRatio, oAway, cube);

	if( doubled ) {
	  *doubled = now;
	
	  doubled->yLow = -eWhenWinPost(oGammonRatio, oAway, 4*cube);
	}
      }
    }
  }
  
#if defined( DEBUG )
  if( debug == 1 ) {
    cout << " return now = " << now;
    if( doubled ) {
      cout << " doubled " << *doubled;
    }
    cout << endl;
  }
#endif
}

void
getCrawfordEq(Es&          now,
	      uint const   away,
	      float const  gammonRatio)
{
  now.xLow = 0.0;
  now.yLow = -1.0;
  
  now.xHigh = 1.0;
  
  now.yHigh = eWhenWinPost(gammonRatio, away, 1);
}

void
getCrawfordEq(Es&          e,
	      uint const   xAway,
	      uint const   oAway,
	      float const  xgr,
	      float const  ogr)
{
  if( xAway == 1 ) {
    getCrawfordEq(e, oAway, ogr);
    e.reverse();
  } else {
    getCrawfordEq(e, xAway, xgr);
  }
}

void
get(Es&           now,
    Es*           doubled,
    uint const    xAway,
    uint const    oAway,
    uint const    cube,
    float const   xGammonRatio,
    float const   oGammonRatio,
    bool const    crawfordGame
#if defined( DEBUG )
    ,int const    debug
#endif
  )
{
  if( ! crawfordGame ) {
    get(now, doubled, xAway, oAway, cube, xGammonRatio, oGammonRatio
#if defined( DEBUG )
	, debug
#endif
	);
  } else {
    {                                     assert( xAway == 1 || oAway == 1 ); }
    
    getCrawfordEq(now, xAway, oAway, xGammonRatio, oGammonRatio);
    
    if( doubled ) {
      // ??? nonsense, no doubled cube in crawford
      *doubled = now;
    }
  }
}


}


