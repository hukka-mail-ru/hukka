// -*- C++ -*-
#if !defined( BGDEFS_H )
#define BGDEFS_H

/*
 * bgdefs.h
 *
 * by Joseph Heled, 2002
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#if defined( __GNUG__ )
#pragma interface
#endif

#ifdef WIN32
#define for if (1) for
#endif


#include "systypes.h"

namespace BG {

// Library version.
extern const char* const version;
// 
extern const char* const applicationName;


/// A single move in a BG game.
//
class MoveDesc {
public:
  /// Set to empty move.
  //
  void	none(void);

  /// Move description
  //  Comes in pairs, from point @arg{desc}[2*@arg{i}] to
  //  @arg{desc}[2*@arg{i}+1] (@eqn{0 <= i <= 4}).
  //
  //  25 is bar, 0 is home.
  //
  //  First unused position, if any, should be set to -1.
  //
  int	desc[8];
};

inline void
MoveDesc::none(void)
{
  desc[0] = -1;
}

/// Position of probabilities in @ref{CubelessProbs}.
enum {
  /// Player to move wins
  //  @eqn{0 <= p <= 1}.
  WIN = 0,
  
  /// Player to move gammon wins.
  //  @eqn{0 <= g <= 1}.
  WINGAMMON = 1,
  
  /// Player to move backgammon wins.
  WINBACKGAMMON = 2,

  /// Player to move gammon loses.
  LOSEGAMMON = 3,
  
  /// Player to move backgammon loses.
  LOSEBACKGAMMON = 4
};

/// Cubeless Probabilities generated by Neural Nets.
typedef float CubelessProbs[5];

/// The Backgammon board.
class Board {
public:
  /// Empty board.
  //  To be initialized directly.
  //
  Board(void) {}

  /// Copy board from @arg{b}.
  //  When @arg{swap}, swap sides.
  //
  Board(Board const& b, bool swap = false);

  ///
  Board& operator =(Board const& b);

  /// Set board to standard initial position.
  //
  void	initial(void);

  /// Board representation.
  //  Each player has it's own 25 int array. @arg{board}[side][@arg{k}] is the
  //  number of checkers player @arg{side} has on point @arg{k},
  //  Bar is the last (24'th) position, and 0 is point 1.
  //
  uint 	board[2][25];
  
  //@ Overloaded samp{[]}, so that class can be used just like a 2
  //  dimensional array.

  /// 
  inline const uint*	operator[](uint k) const;
  ///
  inline uint*		operator[](uint k);

  /// Swap the 2 sides.
  //
  void	swapSides(void);

  /// Is position a pure race?
  //
  bool	isRace(void) const;

};


inline const uint*
Board::operator[](uint const k) const
{
  return board[k];
}

inline uint*
Board::operator[](uint const k)
{
  return board[k];
}

/// Compare two board for equality.
//
bool operator ==(Board const& b1, Board const& b2);

/// Generic evaluator for one backgammon position.
//
class Evaluator {
public:
  /// Compute cubeless probabilities for @arg{board} and place them in
  /// @arg{probs}.
  //
  //  Player 1 is on the move.
  //
  virtual void 	evaluate(Board const& board, CubelessProbs probs) = 0;
};

}

#endif
